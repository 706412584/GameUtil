# 反作弊模块 - 快速开始

## 5分钟集成指南

### 步骤1：添加依赖 (30秒)

在 `settings.gradle` 确认包含：
```gradle
include ':AntiCheat'
```

在应用模块的 `build.gradle` 添加：
```gradle
dependencies {
    implementation project(':AntiCheat')
}
```

### 步骤2：基础使用 (2分钟)

**最简单的用法：**

```java
import game.app.anticheat.SecurityDetector;

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 创建检测器
        SecurityDetector detector = new SecurityDetector(this, 
            new SecurityDetector.SecurityCallback() {
            
            @Override
            public void onThreatDetected(String type, String desc, int level) {
                // 检测到威胁
                Log.w("Security", type + ": " + desc);
            }
            
            @Override
            public void onDetectionComplete(boolean passed, 
                                           List<DetectionResult> threats) {
                // 检测完成
                if (passed) {
                    // 安全，继续
                    startApp();
                } else {
                    // 有风险
                    handleThreats(threats);
                }
            }
        });
        
        // 执行检测
        detector.performSecurityCheck();
    }
}
```

### 步骤3：处理结果 (2分钟)

**根据安全分数处理：**

```java
private void handleSecurityResult(boolean passed, 
                                  List<DetectionResult> threats) {
    // 获取安全分数 (0-100)
    int score = securityDetector.getSecurityScore();
    
    if (score >= 80) {
        // 高分：正常运行
        Toast.makeText(this, "安全检测通过", Toast.LENGTH_SHORT).show();
        
    } else if (score >= 60) {
        // 中等：警告
        showWarning("检测到安全风险，请注意");
        
    } else {
        // 低分：拒绝运行
        showError("安全检测失败，应用将退出");
        finish();
    }
}
```

## 常用场景

### 场景1：游戏应用启动检测

```java
public class GameActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        SecurityDetector detector = new SecurityDetector(this, callback);
        detector.performSecurityCheck();
    }
    
    private SecurityDetector.SecurityCallback callback = 
        new SecurityDetector.SecurityCallback() {
        
        @Override
        public void onThreatDetected(String type, String desc, int level) {
            if (level >= 5) {
                // 严重威胁：Root、Hook、内存修改器
                // 立即退出
                finish();
                System.exit(0);
            }
        }
        
        @Override
        public void onDetectionComplete(boolean passed, 
                                       List<DetectionResult> threats) {
            if (passed || getSecurityScore() >= 70) {
                startGame();
            } else {
                showSecurityError();
            }
        }
    };
}
```

### 场景2：仅检测Root

```java
import game.app.anticheat.RootDetector;

RootDetector rootDetector = new RootDetector(context);
if (rootDetector.isDeviceRooted()) {
    Toast.makeText(context, "检测到Root设备", Toast.LENGTH_SHORT).show();
    // 处理Root设备
}
```

### 场景3：仅检测模拟器

```java
import game.app.anticheat.EmulatorDetector;

EmulatorDetector emulatorDetector = new EmulatorDetector(context);
if (emulatorDetector.isEmulator()) {
    Toast.makeText(context, "检测到模拟器", Toast.LENGTH_SHORT).show();
    // 处理模拟器
}
```

### 场景4：签名验证

```java
import game.app.anticheat.SignatureValidator;

SignatureValidator validator = new SignatureValidator(context);

// 1. 开发阶段：获取签名
String signature = validator.getCurrentSignatureSHA256();
Log.i("Signature", "应用签名: " + signature);
// 复制这个签名值，用于正式版本

// 2. 正式版本：验证签名
validator.setExpectedSignature("YOUR_RELEASE_SIGNATURE_SHA256_HERE");
if (!validator.verifySignature()) {
    // 签名被篡改，应用被重新打包
    Toast.makeText(context, "应用签名异常", Toast.LENGTH_SHORT).show();
    finish();
}
```

### 场景5：定期检测

```java
// 每5分钟检测一次
Handler handler = new Handler(Looper.getMainLooper());
Runnable checkTask = new Runnable() {
    @Override
    public void run() {
        performSecurityCheck();
        handler.postDelayed(this, 5 * 60 * 1000);
    }
};
handler.post(checkTask);

private void performSecurityCheck() {
    new Thread(() -> {
        SecurityDetector detector = new SecurityDetector(context, callback);
        detector.performSecurityCheck();
    }).start();
}
```

## 高级功能

### 查看详细报告

```java
// 生成完整报告
String report = securityDetector.generateSecurityReport();
System.out.println(report);

// 输出示例：
// === 安全检测报告 ===
//
// 安全分数: 85/100
//
// 检测项目:
// - ROOT: ✅ 通过
// - EMULATOR: ✅ 通过
// - HOOK: ✅ 通过
// - DEBUGGER: ❌ 检测到
//   风险等级: 4/5
//   详情: ADB调试已启用
// ...
```

### 获取所有检测结果

```java
Map<String, DetectionResult> results = securityDetector.getResults();

for (Map.Entry<String, DetectionResult> entry : results.entrySet()) {
    DetectionResult result = entry.getValue();
    
    System.out.println("类型: " + result.type);
    System.out.println("检测到: " + result.detected);
    System.out.println("风险等级: " + result.riskLevel);
    System.out.println("详情: " + result.details);
}
```

## 风险等级说明

| 等级 | 威胁类型 | 建议处理 |
|-----|---------|---------|
| 5 | Root、Hook、内存修改、签名异常 | **立即退出** |
| 4 | 多开、调试器 | 警告并限制功能 |
| 3 | 模拟器、时间作弊 | 记录日志 |
| 2 | 代理 | 仅记录 |

## 注意事项

### ✅ 推荐做法

1. **应用启动时检测**
   ```java
   // 在MainActivity的onCreate中执行
   securityDetector.performSecurityCheck();
   ```

2. **定期后台检测**
   ```java
   // 每隔几分钟检测一次
   handler.postDelayed(checkTask, 5 * 60 * 1000);
   ```

3. **关键操作前检测**
   ```java
   // 支付、交易等操作前检测
   if (securityDetector.getSecurityScore() < 80) {
       // 拒绝操作
   }
   ```

4. **上报服务器**
   ```java
   // 将检测结果上报到服务器
   String report = securityDetector.generateSecurityReport();
   uploadToServer(report);
   ```

### ❌ 注意避免

1. **不要在主线程执行**
   ```java
   // ❌ 错误：会阻塞UI
   // securityDetector.performSecurityCheck(); // 在主线程
   
   // ✅ 正确：已经是异步的，直接调用即可
   securityDetector.performSecurityCheck();
   ```

2. **不要过于频繁检测**
   ```java
   // ❌ 错误：每秒检测
   handler.postDelayed(checkTask, 1000);
   
   // ✅ 正确：5-10分钟检测一次
   handler.postDelayed(checkTask, 5 * 60 * 1000);
   ```

3. **不要忽略所有威胁**
   ```java
   // ❌ 错误：检测到Root但不处理
   if (rootDetector.isDeviceRooted()) {
       // 什么都不做
   }
   
   // ✅ 正确：至少记录日志
   if (rootDetector.isDeviceRooted()) {
       Log.w("Security", "检测到Root设备");
       reportToServer("ROOT");
   }
   ```

## 获取帮助

- 📖 [完整文档](使用指南.md)
- 📖 [架构设计](架构设计.md)
- 💻 [示例代码](src/main/java/game/app/anticheat/AntiCheatExample.java)
- 🔧 [集成示例](../app/src/main/java/com/example/IntegratedSecurityExample.java)

## 下一步

1. 阅读 [使用指南.md](使用指南.md) 了解详细功能
2. 查看 [架构设计.md](架构设计.md) 了解实现原理
3. 参考 [AntiCheatExample.java](src/main/java/game/app/anticheat/AntiCheatExample.java) 学习高级用法

---

开始使用，5分钟保护你的应用！ 🔐

