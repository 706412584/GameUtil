# Android 反作弊模块使用指南

## 目录
- [简介](#简介)
- [核心功能](#核心功能)
- [快速开始](#快速开始)
- [详细使用](#详细使用)
- [检测原理](#检测原理)
- [最佳实践](#最佳实践)
- [性能优化](#性能优化)
- [常见问题](#常见问题)

## 简介

Android 反作弊模块是一个专业的应用安全检测库，旨在帮助开发者检测和防止常见的破解、作弊和篡改行为。

### 适用场景

- 🎮 游戏应用防作弊
- 💰 金融应用安全检测
- 📱 应用防篡改保护
- 🔐 敏感数据保护

## 核心功能

### 1. Root 检测

**检测方法：**
- ✅ 检测 su 命令是否存在
- ✅ 检测 Root 管理应用（SuperSU、Magisk、KernelSU）
- ✅ 检测 Root 隐藏工具
- ✅ 检测 Test-Keys
- ✅ 检测 BusyBox
- ✅ 检测系统目录可写性

**使用示例：**
```java
RootDetector rootDetector = new RootDetector(context);
if (rootDetector.isDeviceRooted()) {
    String details = rootDetector.getRootDetails();
    Log.w("Security", "检测到Root: " + details);
    // 处理逻辑：退出应用或限制功能
}
```

**风险等级：** ⚠️⚠️⚠️⚠️⚠️ (5/5)

**应对策略：**
- 严重场景：直接退出应用
- 一般场景：警告并限制敏感功能
- 宽松场景：仅记录日志

---

### 2. 模拟器检测

**检测方法：**
- ✅ 检测 Build 信息特征
- ✅ 检测 QEMU 特征文件
- ✅ 检测 Genymotion
- ✅ 检测国产模拟器（夜神、雷电、逍遥等）
- ✅ 检测 x86 架构
- ✅ 检测运营商名称异常

**使用示例：**
```java
EmulatorDetector emulatorDetector = new EmulatorDetector(context);
if (emulatorDetector.isEmulator()) {
    String details = emulatorDetector.getEmulatorDetails();
    Log.w("Security", "检测到模拟器: " + details);
}
```

**风险等级：** ⚠️⚠️⚠️ (3/5)

**应对策略：**
- 游戏应用：限制功能或提高风控
- 普通应用：仅记录，允许使用

---

### 3. Hook 框架检测

**检测方法：**
- ✅ 检测 Xposed 框架
- ✅ 检测 Frida 框架
- ✅ 检测 Substrate
- ✅ 检测 Virtual Xposed
- ✅ 检测内存中的 Hook 库
- ✅ 检测堆栈异常
- ✅ 检测 Frida 端口

**使用示例：**
```java
HookDetector hookDetector = new HookDetector(context);
if (hookDetector.detectHookFramework()) {
    String details = hookDetector.getHookDetails();
    Log.e("Security", "检测到Hook框架: " + details);
    // 严重威胁，建议退出
}
```

**风险等级：** ⚠️⚠️⚠️⚠️⚠️ (5/5)

**应对策略：**
- **必须退出应用**
- Hook 框架可以完全控制应用行为

---

### 4. 调试器检测

**检测方法：**
- ✅ 检测调试器连接
- ✅ 检测 Debug 标志
- ✅ 检测 TracerPid
- ✅ 检测调试端口
- ✅ 检测 ADB 状态

**使用示例：**
```java
DebugDetector debugDetector = new DebugDetector(context);
if (debugDetector.isBeingDebugged()) {
    String details = debugDetector.getDebugDetails();
    Log.w("Security", "检测到调试器: " + details);
}
```

**风险等级：** ⚠️⚠️⚠️⚠️ (4/5)

**应对策略：**
- Release 版本：严格禁止
- Debug 版本：允许调试

---

### 5. 签名验证

**检测方法：**
- ✅ 验证应用签名 SHA256
- ✅ 检测二次打包
- ✅ 验证证书有效期
- ✅ 检测 Debug 证书

**使用示例：**
```java
SignatureValidator validator = new SignatureValidator(context);

// 获取当前签名（开发阶段）
String currentSig = validator.getCurrentSignatureSHA256();
Log.i("Signature", "当前签名: " + currentSig);

// 设置期望签名并验证（生产环境）
validator.setExpectedSignature("YOUR_RELEASE_SIGNATURE_SHA256");
if (!validator.verifySignature()) {
    String details = validator.getSignatureDetails();
    Log.e("Security", "签名验证失败: " + details);
    // 应用被篡改，必须退出
}
```

**风险等级：** ⚠️⚠️⚠️⚠️⚠️ (5/5)

**应对策略：**
- **必须退出应用**
- 签名不匹配说明应用被重新打包

**获取签名方法：**
```bash
# 使用 keytool
keytool -list -v -keystore your.keystore

# 或在代码中获取
SignatureValidator validator = new SignatureValidator(context);
String signature = validator.getCurrentSignatureSHA256();
```

---

### 6. 代理检测

**检测方法：**
- ✅ 检测系统代理
- ✅ 检测 HTTP 代理
- ✅ 检测 VPN 连接

**使用示例：**
```java
ProxyDetector proxyDetector = new ProxyDetector(context);
if (proxyDetector.isProxySet()) {
    String details = proxyDetector.getProxyDetails();
    Log.w("Security", "检测到代理: " + details);
}
```

**风险等级：** ⚠️⚠️ (2/5)

**应对策略：**
- 金融应用：禁止代理
- 普通应用：仅记录

---

### 7. 多开检测

**检测方法：**
- ✅ 检测平行空间
- ✅ 检测双开助手
- ✅ 检测 VirtualApp
- ✅ 检测数据路径异常
- ✅ 检测多进程实例

**使用示例：**
```java
MultiInstanceDetector multiDetector = new MultiInstanceDetector(context);
if (multiDetector.isRunningInVirtualApp()) {
    String details = multiDetector.getMultiInstanceDetails();
    Log.w("Security", "检测到多开: " + details);
}
```

**风险等级：** ⚠️⚠️⚠️⚠️ (4/5)

**应对策略：**
- 游戏：严格禁止
- 社交应用：可能允许

---

### 8. 内存修改器检测

**检测方法：**
- ✅ 检测 GameGuardian
- ✅ 检测 Cheat Engine
- ✅ 检测 GameKiller
- ✅ 检测内存映射异常
- ✅ 检测可疑进程

**使用示例：**
```java
MemoryHackDetector memoryDetector = new MemoryHackDetector(context);
if (memoryDetector.detectMemoryHackTools()) {
    String details = memoryDetector.getMemoryHackDetails();
    Log.e("Security", "检测到内存修改工具: " + details);
    // 严重威胁，立即退出
}
```

**风险等级：** ⚠️⚠️⚠️⚠️⚠️ (5/5)

**应对策略：**
- **必须退出应用**
- 可以任意修改游戏数值

---

### 9. 时间作弊检测

**检测方法：**
- ✅ 检测系统时间跳跃
- ✅ 检测启动时间异常
- ✅ 服务器时间同步验证

**使用示例：**
```java
TimeCheatDetector timeDetector = new TimeCheatDetector(context);

// 设置服务器时间
long serverTime = getServerTime(); // 从服务器获取
timeDetector.setServerTime(serverTime);

// 检测时间作弊
if (timeDetector.detectTimeManipulation()) {
    String details = timeDetector.getTimeCheatDetails();
    Log.w("Security", "检测到时间修改: " + details);
    
    // 获取时间偏差
    long diff = timeDetector.getTimeDifference();
    Log.i("TimeDiff", "时间偏差: " + diff + "ms");
}
```

**风险等级：** ⚠️⚠️⚠️ (3/5)

**应对策略：**
- 时间敏感应用：严格禁止
- 普通应用：校正时间后继续

---

## 快速开始

### 1. 集成模块

在 `settings.gradle` 中添加：
```gradle
include ':AntiCheat'
```

在应用模块的 `build.gradle` 中添加：
```gradle
dependencies {
    implementation project(':AntiCheat')
}
```

### 2. 基础用法

```java
public class MainActivity extends Activity {
    
    private SecurityDetector securityDetector;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 初始化安全检测器
        initSecurityDetector();
        
        // 执行检测
        securityDetector.performSecurityCheck();
    }
    
    private void initSecurityDetector() {
        securityDetector = new SecurityDetector(this, 
            new SecurityDetector.SecurityCallback() {
            
            @Override
            public void onThreatDetected(String threatType, 
                                       String description, 
                                       int riskLevel) {
                // 实时威胁通知
                Log.w("Security", String.format(
                    "[%s] %s (风险:%d)", 
                    threatType, description, riskLevel
                ));
            }
            
            @Override
            public void onDetectionComplete(boolean passed, 
                                           List<DetectionResult> threats) {
                // 检测完成处理
                handleSecurityResult(passed, threats);
            }
        });
    }
    
    private void handleSecurityResult(boolean passed, 
                                      List<DetectionResult> threats) {
        if (!passed) {
            // 未通过安全检测
            showSecurityWarning(threats);
        } else {
            // 通过检测
            continueNormalFlow();
        }
    }
}
```

### 3. 获取安全报告

```java
// 获取安全分数 (0-100)
int score = securityDetector.getSecurityScore();

// 生成详细报告
String report = securityDetector.generateSecurityReport();
System.out.println(report);

// 输出示例：
// === 安全检测报告 ===
//
// 安全分数: 75/100
//
// 检测项目:
// - ROOT: ✅ 通过
// - EMULATOR: ❌ 检测到
//   风险等级: 3/5
//   详情: Build信息特征: Android SDK built for x86
// - HOOK: ✅ 通过
// ...
```

## 详细使用

### 完整检测流程

```java
public class SecurityManager {
    
    private SecurityDetector securityDetector;
    private Context context;
    
    public void performFullSecurityCheck() {
        // 1. 创建检测器
        securityDetector = new SecurityDetector(context, callback);
        
        // 2. 执行检测
        securityDetector.performSecurityCheck();
        
        // 3. 等待结果（异步）
        // 结果会通过回调返回
    }
    
    private SecurityDetector.SecurityCallback callback = 
        new SecurityDetector.SecurityCallback() {
        
        @Override
        public void onThreatDetected(String threatType, 
                                   String description, 
                                   int riskLevel) {
            // 实时处理每个威胁
            handleThreat(threatType, riskLevel);
        }
        
        @Override
        public void onDetectionComplete(boolean passed, 
                                       List<DetectionResult> threats) {
            // 汇总处理
            processResults(passed, threats);
        }
    };
    
    private void handleThreat(String type, int level) {
        // 根据威胁类型和等级处理
        switch (level) {
            case 5: // 严重
                reportToServer(type, level);
                exitApp();
                break;
            case 4: // 高
                reportToServer(type, level);
                showWarning();
                break;
            case 3: // 中
                reportToServer(type, level);
                break;
            default: // 低
                logLocally(type, level);
                break;
        }
    }
    
    private void processResults(boolean passed, 
                               List<DetectionResult> threats) {
        // 生成报告
        String report = securityDetector.generateSecurityReport();
        
        // 上报服务器
        uploadSecurityReport(report);
        
        // 本地记录
        saveSecurityLog(report);
        
        // UI 反馈
        if (!passed) {
            showSecurityDialog(threats);
        }
    }
}
```

### 自定义检测策略

```java
public class CustomSecurityCheck {
    
    // 策略1：仅检测关键威胁
    public boolean checkCriticalThreats(Context context) {
        // 只检测风险等级 >= 4 的威胁
        RootDetector rootDetector = new RootDetector(context);
        HookDetector hookDetector = new HookDetector(context);
        MemoryHackDetector memDetector = new MemoryHackDetector(context);
        SignatureValidator sigValidator = new SignatureValidator(context);
        
        return rootDetector.isDeviceRooted()
            || hookDetector.detectHookFramework()
            || memDetector.detectMemoryHackTools()
            || !sigValidator.verifySignature();
    }
    
    // 策略2：分级检测
    public SecurityLevel getSecurityLevel(Context context) {
        SecurityDetector detector = new SecurityDetector(context, null);
        detector.performSecurityCheck();
        
        int score = detector.getSecurityScore();
        
        if (score >= 90) return SecurityLevel.SAFE;
        if (score >= 70) return SecurityLevel.WARNING;
        if (score >= 50) return SecurityLevel.DANGER;
        return SecurityLevel.CRITICAL;
    }
    
    // 策略3：定期后台检测
    public void startPeriodicCheck(Context context) {
        Handler handler = new Handler(Looper.getMainLooper());
        Runnable checkTask = new Runnable() {
            @Override
            public void run() {
                performBackgroundCheck(context);
                // 每5分钟检测一次
                handler.postDelayed(this, 5 * 60 * 1000);
            }
        };
        handler.post(checkTask);
    }
    
    private void performBackgroundCheck(Context context) {
        // 后台检测（不阻塞UI）
        new Thread(() -> {
            SecurityDetector detector = new SecurityDetector(
                context, 
                createSilentCallback()
            );
            detector.performSecurityCheck();
        }).start();
    }
}
```

## 检测原理

### Root 检测原理

1. **su 命令检测**
   - 检查常见的 su 文件路径
   - `/system/bin/su`、`/system/xbin/su` 等

2. **Root 应用检测**
   - 检查是否安装 SuperSU、Magisk 等应用
   - 通过 PackageManager 查询包名

3. **系统属性检测**
   - 检查 `ro.build.tags` 是否包含 `test-keys`
   - 检查 `ro.debuggable` 和 `ro.secure` 属性

### 模拟器检测原理

1. **Build 信息检测**
   - 检查 `Build.MODEL`、`Build.MANUFACTURER` 等
   - 模拟器通常包含 `sdk`、`Emulator` 等关键词

2. **硬件特征检测**
   - 检查 CPU 架构（x86 通常是模拟器）
   - 检查硬件名称（goldfish、vbox86等）

3. **文件特征检测**
   - 检查 `/dev/socket/qemud` 等QEMU特征文件

### Hook 框架检测原理

1. **堆栈检测**
   - 抛出异常并检查堆栈信息
   - 查找 Xposed、Substrate 特征

2. **内存检测**
   - 读取 `/proc/self/maps`
   - 查找 Hook 框架相关的库文件

3. **端口检测**
   - 检查 Frida 默认端口 27042

## 最佳实践

### 1. 应用启动检测

```java
public class SplashActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // 显示启动画面
        setContentView(R.layout.activity_splash);
        
        // 执行安全检测
        performSecurityCheck();
    }
    
    private void performSecurityCheck() {
        SecurityDetector detector = new SecurityDetector(this, 
            new SecurityDetector.SecurityCallback() {
            
            @Override
            public void onThreatDetected(String type, String desc, int level) {
                // 记录威胁
            }
            
            @Override
            public void onDetectionComplete(boolean passed, 
                                           List<DetectionResult> threats) {
                if (passed || canContinueWithWarning(threats)) {
                    // 进入主界面
                    startMainActivity();
                } else {
                    // 显示错误并退出
                    showSecurityErrorAndExit(threats);
                }
            }
        });
        
        detector.performSecurityCheck();
    }
}
```

### 2. 关键操作前检测

```java
public class PaymentActivity extends Activity {
    
    private void processPayment() {
        // 支付前进行安全检测
        SecurityDetector detector = new SecurityDetector(this, null);
        detector.performSecurityCheck();
        
        int score = detector.getSecurityScore();
        if (score < 80) {
            // 安全分数过低，拒绝支付
            showDialog("安全环境异常，无法完成支付");
            return;
        }
        
        // 继续支付流程
        continuePayment();
    }
}
```

### 3. 服务器验证结合

```java
public class ServerVerification {
    
    public void submitSecurityReport(Context context) {
        SecurityDetector detector = new SecurityDetector(context, null);
        detector.performSecurityCheck();
        
        // 获取检测结果
        Map<String, DetectionResult> results = detector.getResults();
        
        // 构造上报数据
        JSONObject reportData = new JSONObject();
        for (Map.Entry<String, DetectionResult> entry : results.entrySet()) {
            DetectionResult result = entry.getValue();
            JSONObject item = new JSONObject();
            item.put("detected", result.detected);
            item.put("riskLevel", result.riskLevel);
            item.put("details", result.details);
            reportData.put(entry.getKey(), item);
        }
        
        // 上报到服务器
        uploadToServer(reportData);
    }
    
    private void uploadToServer(JSONObject data) {
        // 调用服务器 API
        // POST /api/security/report
    }
}
```

## 性能优化

### 1. 异步检测

所有检测都在后台线程执行，不会阻塞主线程：

```java
// SecurityDetector 内部已经使用了 Thread
securityDetector.performSecurityCheck();
// 不会阻塞，结果通过回调返回
```

### 2. 按需检测

```java
// 只检测需要的项目
if (needRootCheck) {
    RootDetector detector = new RootDetector(context);
    detector.isDeviceRooted();
}

if (needHookCheck) {
    HookDetector detector = new HookDetector(context);
    detector.detectHookFramework();
}
```

### 3. 缓存结果

```java
public class SecurityCache {
    private static Map<String, Boolean> cache = new HashMap<>();
    private static long lastCheckTime = 0;
    private static final long CACHE_DURATION = 5 * 60 * 1000; // 5分钟
    
    public static boolean isDeviceRooted(Context context) {
        long now = System.currentTimeMillis();
        if (now - lastCheckTime < CACHE_DURATION && cache.containsKey("root")) {
            return cache.get("root");
        }
        
        RootDetector detector = new RootDetector(context);
        boolean result = detector.isDeviceRooted();
        
        cache.put("root", result);
        lastCheckTime = now;
        
        return result;
    }
}
```

## 常见问题

### Q1: 检测会影响应用性能吗？

A: 不会。所有检测都在后台线程执行，完整检测耗时约 100-500ms，对用户体验影响极小。

### Q2: 如何处理误报？

A: 
1. 根据实际情况调整风险等级阈值
2. 某些检测项（如模拟器）可设为仅记录
3. 结合服务器端验证提高准确性

### Q3: 检测可以被绕过吗？

A: 任何客户端检测都可能被绕过。建议：
- 多重检测提高绕过难度
- 配合代码混淆和加固
- 重要操作必须经过服务器验证

### Q4: 需要哪些权限？

A: 大部分检测不需要额外权限。特殊情况：
- 代理检测需要 `ACCESS_NETWORK_STATE`
- 建议添加：`android.permission.INTERNET`（上报数据）

### Q5: 如何获取应用签名？

```java
// 方法1：运行时获取
SignatureValidator validator = new SignatureValidator(context);
String sig = validator.getCurrentSignatureSHA256();
Log.i("Signature", sig);

// 方法2：使用 keytool
// keytool -list -v -keystore your.keystore
```

### Q6: 发布版本如何配置？

```java
// 1. 获取正式签名
String releaseSignature = "YOUR_RELEASE_SIGNATURE_SHA256";

// 2. 配置签名验证
SignatureValidator validator = new SignatureValidator(context);
validator.setExpectedSignature(releaseSignature);

// 3. 严格模式
if (!validator.verifySignature()) {
    // 签名异常，立即退出
    android.os.Process.killProcess(android.os.Process.myPid());
}
```

### Q7: 如何与服务器配合？

```java
// 客户端上报检测结果
securityDetector.performSecurityCheck();
String report = securityDetector.generateSecurityReport();
uploadToServer(report);

// 服务器端验证
// 1. 记录异常设备
// 2. 结合行为分析
// 3. 必要时封禁账号
```

### Q8: 测试环境如何处理？

```java
public class SecurityConfig {
    public static boolean isDebugMode() {
        return BuildConfig.DEBUG;
    }
    
    public static void performSecurityCheck(Context context) {
        if (isDebugMode()) {
            // 测试环境：宽松模式
            Log.d("Security", "Debug模式，跳过部分检测");
            return;
        }
        
        // 正式环境：严格检测
        SecurityDetector detector = new SecurityDetector(context, callback);
        detector.performSecurityCheck();
    }
}
```

## 技术支持

如有问题，请查看：
- [README.md](README.md) - 快速开始
- [示例代码](src/main/java/game/app/anticheat/AntiCheatExample.java)

---

**最后更新:** 2025-01-01  
**版本:** 1.0.0

