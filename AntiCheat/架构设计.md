# 反作弊模块架构设计文档

## 目录
1. [系统概述](#系统概述)
2. [架构设计](#架构设计)
3. [核心组件](#核心组件)
4. [检测原理](#检测原理)
5. [性能优化](#性能优化)
6. [安全加固](#安全加固)
7. [扩展指南](#扩展指南)

---

## 系统概述

### 设计目标

反作弊模块旨在为 Android 应用提供全面的安全保护，检测和防止常见的破解、作弊和篡改行为。

### 核心特性

- ✅ **全面检测** - 覆盖10种常见威胁类型
- ✅ **分级响应** - 根据风险等级灵活处理
- ✅ **实时监控** - 支持异步检测和实时回调
- ✅ **性能优化** - 后台执行，不阻塞主线程
- ✅ **可扩展性** - 模块化设计，易于扩展

### 威胁类型

| 类型 | 风险等级 | 描述 |
|-----|---------|------|
| Root | 5 | 设备已获取Root权限 |
| Hook框架 | 5 | 检测到Xposed/Frida等 |
| 内存修改器 | 5 | 检测到GameGuardian等 |
| 签名异常 | 5 | 应用被重新打包 |
| 多开 | 4 | 虚拟环境/多开应用 |
| 调试器 | 4 | 应用正在被调试 |
| 模拟器 | 3 | 运行在模拟器中 |
| 时间作弊 | 3 | 系统时间被修改 |
| 代理 | 2 | 网络代理设置 |

---

## 架构设计

### 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    应用层 (Application)                   │
│  ┌──────────────────────────────────────────────────┐  │
│  │           IntegratedSecurityExample               │  │
│  │  (集成示例：安全检测 + 存档管理)                    │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                           ▼
┌─────────────────────────────────────────────────────────┐
│                 核心层 (SecurityDetector)                │
│  ┌──────────────────────────────────────────────────┐  │
│  │  • performSecurityCheck()   - 执行完整检测        │  │
│  │  • getSecurityScore()       - 获取安全分数        │  │
│  │  • generateSecurityReport() - 生成检测报告        │  │
│  │  • SecurityCallback         - 异步回调接口        │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                           ▼
┌─────────────────────────────────────────────────────────┐
│                检测层 (Detection Modules)                │
│  ┌─────────┬─────────┬─────────┬─────────┬─────────┐  │
│  │  Root   │Emulator │  Hook   │ Debug   │Signature│  │
│  │Detector │Detector │Detector │Detector │Validator│  │
│  └─────────┴─────────┴─────────┴─────────┴─────────┘  │
│  ┌─────────┬─────────┬─────────┬─────────┐            │
│  │  Proxy  │ Multi   │ Memory  │  Time   │            │
│  │Detector │Instance │  Hack   │ Cheat   │            │
│  └─────────┴─────────┴─────────┴─────────┘            │
└─────────────────────────────────────────────────────────┘
                           ▼
┌─────────────────────────────────────────────────────────┐
│              系统层 (Android System APIs)                │
│  • PackageManager  • Build  • Debug  • Process         │
│  • /proc 文件系统  • 反射   • JNI    • 文件检查        │
└─────────────────────────────────────────────────────────┘
```

### 模块职责

#### 1. SecurityDetector（核心协调器）

**职责：**
- 统一管理所有检测器
- 协调检测流程
- 汇总检测结果
- 计算安全分数
- 触发回调

**关键方法：**
```java
public void performSecurityCheck()
public int getSecurityScore()
public String generateSecurityReport()
public Map<String, DetectionResult> getResults()
```

#### 2. 各检测器（独立模块）

每个检测器都是独立的，遵循相同的接口模式：

```java
// 检测方法
public boolean isXxxDetected()

// 获取详情
public String getXxxDetails()

// 内部成员
private List<String> detectedMethods
```

---

## 核心组件

### 1. RootDetector（Root检测器）

**检测策略：**

```
检测流程
  ├── 文件检测
  │   ├── 检查su命令路径 (/system/bin/su, /system/xbin/su...)
  │   ├── 检查BusyBox
  │   └── 检查Root隐藏工具文件
  │
  ├── 应用检测
  │   ├── 检测SuperSU
  │   ├── 检测Magisk
  │   ├── 检测KernelSU
  │   └── 检测Root隐藏应用
  │
  ├── 系统属性检测
  │   ├── 检查Build.TAGS (test-keys)
  │   ├── 检查ro.debuggable
  │   └── 检查ro.secure
  │
  └── 权限检测
      └── 检查系统目录写权限
```

**代码示例：**
```java
// 检查su文件
for (String path : SU_PATHS) {
    if (new File(path).exists()) {
        detectedMethods.add("检测到su文件: " + path);
        return true;
    }
}

// 检查Root应用
for (String packageName : ROOT_APPS) {
    try {
        context.getPackageManager().getPackageInfo(packageName, 0);
        detectedMethods.add("检测到Root应用: " + packageName);
        return true;
    } catch (Exception ignored) {}
}
```

### 2. EmulatorDetector（模拟器检测器）

**检测策略：**

```
检测流程
  ├── Build信息检测
  │   ├── Build.MODEL (包含"Emulator", "SDK"等)
  │   ├── Build.MANUFACTURER (Genymotion等)
  │   ├── Build.HARDWARE (goldfish, vbox86等)
  │   └── Build.PRODUCT (google_sdk等)
  │
  ├── 硬件特征检测
  │   ├── CPU架构 (x86通常是模拟器)
  │   ├── 运营商名称 ("android"异常)
  │   └── IMEI/设备ID异常
  │
  ├── 文件特征检测
  │   ├── /dev/socket/qemud (QEMU)
  │   ├── /dev/qemu_pipe
  │   └── Genymotion特征文件
  │
  └── 内存特征检测
      └── /proc/self/maps (检查qemu/vbox特征)
```

### 3. HookDetector（Hook框架检测器）

**检测策略：**

```
检测流程
  ├── Xposed检测
  │   ├── 检测Xposed包名
  │   ├── 检测XposedBridge.jar
  │   ├── 检测libxposed_art.so
  │   ├── 堆栈检测
  │   └── ClassLoader检测
  │
  ├── Frida检测
  │   ├── 检测frida-agent库
  │   ├── 检测frida-server
  │   ├── 检测27042端口
  │   ├── 检测/proc/maps中的frida
  │   └── 检测gum-js-loop线程
  │
  ├── Substrate检测
  │   ├── 检测com.saurik.substrate类
  │   ├── 检测libsubstrate.so
  │   └── 堆栈检测
  │
  └── VirtualXposed检测
      └── 检测数据路径异常
```

**关键代码：**
```java
// 堆栈检测Xposed
try {
    throw new Exception("检测");
} catch (Exception e) {
    for (StackTraceElement element : e.getStackTrace()) {
        if (element.getClassName().contains("de.robv.android.xposed")) {
            return true;
        }
    }
}

// 检测Frida端口
BufferedReader reader = new BufferedReader(new FileReader("/proc/net/tcp"));
while ((line = reader.readLine()) != null) {
    if (line.contains(":69CA")) { // 27042 = 0x69CA
        return true;
    }
}
```

### 4. MemoryHackDetector（内存修改器检测器）

**检测策略：**

```
检测流程
  ├── 应用检测
  │   ├── GameGuardian (catch_.me_.if_.you_.can_)
  │   ├── Cheat Engine
  │   ├── GameKiller
  │   └── 其他作弊工具
  │
  ├── 文件检测
  │   ├── /sdcard/GameGuardian
  │   └── /sdcard/ggsaves
  │
  ├── 内存检测
  │   ├── /proc/self/maps (检查异常库)
  │   ├── TracerPid (是否被附加)
  │   └── 匿名内存映射数量
  │
  └── 进程检测
      └── 检测可疑跟踪进程
```

### 5. TimeCheatDetector（时间作弊检测器）

**检测策略：**

```
检测流程
  ├── 系统时间跳跃检测
  │   ├── System.currentTimeMillis()
  │   ├── SystemClock.elapsedRealtime()
  │   └── 比较两者差异
  │
  ├── 启动时间检测
  │   ├── 计算bootTime = currentTime - elapsedRealtime
  │   ├── 与上次保存的bootTime对比
  │   └── 检测异常跳跃
  │
  └── 服务器时间同步
      ├── 记录服务器时间
      ├── 根据elapsedRealtime计算期望时间
      └── 与当前系统时间对比
```

**关键代码：**
```java
// 时间跳跃检测
long currentTime = System.currentTimeMillis();
long elapsedRealtime = SystemClock.elapsedRealtime();

if (lastLocalTime > 0) {
    long timeDiff = currentTime - lastLocalTime;
    long realtimeDiff = elapsedRealtime - lastElapsedRealtime;
    
    // 如果差异过大，说明时间被修改
    if (Math.abs(timeDiff - realtimeDiff) > ALLOWED_TIME_DIFF) {
        return true;
    }
}
```

---

## 检测原理

### 原理1：文件系统检测

**方法：** 检查特定路径是否存在文件/目录

**示例：**
```java
// Root检测：查找su命令
String[] paths = {"/system/bin/su", "/system/xbin/su", "/sbin/su"};
for (String path : paths) {
    if (new File(path).exists()) {
        return true;
    }
}

// Xposed检测：查找特征文件
if (new File("/system/framework/XposedBridge.jar").exists()) {
    return true;
}
```

### 原理2：进程信息检测

**方法：** 读取 /proc 文件系统获取进程信息

**示例：**
```java
// 检测TracerPid
BufferedReader reader = new BufferedReader(
    new FileReader("/proc/self/status"));

while ((line = reader.readLine()) != null) {
    if (line.startsWith("TracerPid:")) {
        int pid = Integer.parseInt(line.split(":")[1].trim());
        if (pid != 0) {
            return true; // 被调试
        }
    }
}

// 检测内存映射
reader = new BufferedReader(new FileReader("/proc/self/maps"));
while ((line = reader.readLine()) != null) {
    if (line.contains("frida") || line.contains("xposed")) {
        return true;
    }
}
```

### 原理3：Build信息检测

**方法：** 检查 android.os.Build 类的静态字段

**示例：**
```java
// 模拟器检测
if (Build.FINGERPRINT.startsWith("generic")
    || Build.MODEL.contains("Emulator")
    || Build.MANUFACTURER.contains("Genymotion")
    || Build.HARDWARE.equals("goldfish")) {
    return true;
}

// Root检测
if (Build.TAGS != null && Build.TAGS.contains("test-keys")) {
    return true;
}
```

### 原理4：PackageManager检测

**方法：** 查询已安装的应用包

**示例：**
```java
// 检测Root管理应用
String[] packages = {"com.topjohnwu.magisk", "eu.chainfire.supersu"};
for (String pkg : packages) {
    try {
        context.getPackageManager().getPackageInfo(pkg, 0);
        return true; // 安装了Root应用
    } catch (PackageManager.NameNotFoundException e) {
        // 未安装
    }
}
```

### 原理5：异常堆栈检测

**方法：** 主动抛出异常并分析堆栈

**示例：**
```java
// 检测Xposed
try {
    throw new Exception();
} catch (Exception e) {
    for (StackTraceElement element : e.getStackTrace()) {
        String className = element.getClassName();
        if (className.contains("de.robv.android.xposed")
            || className.contains("com.saurik.substrate")) {
            return true;
        }
    }
}
```

### 原理6：系统属性检测

**方法：** 通过反射获取系统属性

**示例：**
```java
// 获取系统属性
Class<?> c = Class.forName("android.os.SystemProperties");
Method get = c.getMethod("get", String.class);
String value = (String) get.invoke(c, "ro.debuggable");

if ("1".equals(value)) {
    return true; // 可调试
}
```

---

## 性能优化

### 1. 异步执行

所有检测都在后台线程执行：

```java
public void performSecurityCheck() {
    new Thread(() -> {
        // 执行各项检测
        checkRoot();
        checkEmulator();
        // ...
        
        // 回调结果
        summarizeResults();
    }).start();
}
```

### 2. 延迟加载

检测器采用懒加载模式：

```java
private RootDetector rootDetector;

private RootDetector getRootDetector() {
    if (rootDetector == null) {
        rootDetector = new RootDetector(context);
    }
    return rootDetector;
}
```

### 3. 缓存结果

对于耗时的检测，可以缓存结果：

```java
private static boolean cachedRootResult = false;
private static long lastCheckTime = 0;
private static final long CACHE_DURATION = 5 * 60 * 1000; // 5分钟

public boolean isDeviceRooted() {
    long now = System.currentTimeMillis();
    if (now - lastCheckTime < CACHE_DURATION) {
        return cachedRootResult;
    }
    
    cachedRootResult = performRootCheck();
    lastCheckTime = now;
    return cachedRootResult;
}
```

### 4. 性能统计

| 检测类型 | 平均耗时 | 说明 |
|---------|---------|------|
| Root检测 | 10-30ms | 文件IO密集 |
| 模拟器检测 | 20-50ms | 包含进程读取 |
| Hook检测 | 30-80ms | 堆栈分析较慢 |
| 调试器检测 | 5-15ms | 系统API调用 |
| 签名验证 | 10-30ms | 证书解析 |
| 其他检测 | 5-20ms | - |
| **完整检测** | **100-300ms** | 并发执行 |

---

## 安全加固

### 1. 代码混淆

**proguard-rules.pro:**
```proguard
# 保留接口
-keep public class game.app.anticheat.SecurityDetector {
    public *;
}

# 混淆检测器
-keep class game.app.anticheat.**Detector { *; }
-obfuscate
-optimizations !code/allocation/variable

# 字符串加密
-adaptresourcefilecontents
```

### 2. 防止反射攻击

```java
// 检查调用者
private void checkCaller() {
    StackTraceElement[] stack = Thread.currentThread().getStackTrace();
    if (stack.length > 3) {
        String caller = stack[3].getClassName();
        if (!caller.startsWith("game.app.anticheat")) {
            throw new SecurityException("Unauthorized access");
        }
    }
}
```

### 3. JNI层实现

关键检测逻辑可以用Native代码实现：

```c
// native-lib.cpp
JNIEXPORT jboolean JNICALL
Java_game_app_anticheat_RootDetector_nativeCheckRoot(
    JNIEnv* env, jobject obj) {
    
    // C层检测，更难被Hook
    return access("/system/bin/su", F_OK) == 0;
}
```

### 4. 多重验证

```java
// 组合多个检测方法
public boolean isRootedWithConfidence() {
    int score = 0;
    
    if (checkSuExists()) score++;
    if (checkRootApps()) score++;
    if (checkBusyBox()) score++;
    if (checkRWPaths()) score++;
    
    // 需要多个证据才确认
    return score >= 2;
}
```

---

## 扩展指南

### 添加新检测器

#### 步骤1：创建检测器类

```java
public class NewThreatDetector {
    private final Context context;
    private final List<String> detectedMethods = new ArrayList<>();
    
    public NewThreatDetector(Context context) {
        this.context = context.getApplicationContext();
    }
    
    public boolean detectNewThreat() {
        detectedMethods.clear();
        
        // 实现检测逻辑
        if (checkMethod1()) return true;
        if (checkMethod2()) return true;
        
        return false;
    }
    
    public String getDetails() {
        if (detectedMethods.isEmpty()) {
            return "未检测到新威胁";
        }
        return String.join("; ", detectedMethods);
    }
    
    private boolean checkMethod1() {
        // 检测逻辑1
        return false;
    }
    
    private boolean checkMethod2() {
        // 检测逻辑2
        return false;
    }
}
```

#### 步骤2：集成到SecurityDetector

```java
public class SecurityDetector {
    private final NewThreatDetector newThreatDetector;
    
    public SecurityDetector(Context context, SecurityCallback callback) {
        // ...
        this.newThreatDetector = new NewThreatDetector(context);
    }
    
    public void performSecurityCheck() {
        new Thread(() -> {
            // ...
            checkNewThreat();
            // ...
        }).start();
    }
    
    private void checkNewThreat() {
        boolean detected = newThreatDetector.detectNewThreat();
        String details = newThreatDetector.getDetails();
        
        DetectionResult result = new DetectionResult(
            "NEW_THREAT",
            "新威胁检测",
            detected ? 4 : 0,  // 风险等级
            detected,
            details
        );
        
        results.put("NEW_THREAT", result);
        
        if (detected && callback != null) {
            callback.onThreatDetected("NEW_THREAT", "检测到新威胁", 4);
        }
    }
}
```

### 自定义检测策略

```java
public class CustomSecurityPolicy {
    
    // 策略1：游戏专用
    public static boolean checkForGame(Context context) {
        SecurityDetector detector = new SecurityDetector(context, null);
        detector.performSecurityCheck();
        
        Map<String, DetectionResult> results = detector.getResults();
        
        // 游戏严格禁止：Root、Hook、内存修改
        return !results.get("ROOT").detected
            && !results.get("HOOK").detected
            && !results.get("MEMORY_HACK").detected;
    }
    
    // 策略2：金融应用专用
    public static boolean checkForFinance(Context context) {
        SecurityDetector detector = new SecurityDetector(context, null);
        detector.performSecurityCheck();
        
        // 金融应用要求最高安全级别
        return detector.getSecurityScore() >= 90;
    }
    
    // 策略3：自定义权重
    public static int getCustomScore(Context context) {
        SecurityDetector detector = new SecurityDetector(context, null);
        detector.performSecurityCheck();
        
        Map<String, DetectionResult> results = detector.getResults();
        
        int score = 100;
        
        // 自定义权重
        if (results.get("ROOT").detected) score -= 40;
        if (results.get("HOOK").detected) score -= 40;
        if (results.get("EMULATOR").detected) score -= 10;
        if (results.get("DEBUGGER").detected) score -= 20;
        
        return Math.max(0, score);
    }
}
```

---

## 总结

### 优势

1. ✅ **全面性** - 覆盖10种常见威胁
2. ✅ **准确性** - 多种检测方法交叉验证
3. ✅ **性能** - 异步执行，不影响体验
4. ✅ **灵活性** - 分级处理，可自定义策略
5. ✅ **可扩展** - 模块化设计，易于添加新检测

### 局限性

1. ⚠️ 客户端检测都可能被绕过
2. ⚠️ 某些检测可能有误报
3. ⚠️ 需要配合服务器端验证
4. ⚠️ 对抗性检测会不断升级

### 建议

1. 🔐 配合代码混淆和加固
2. 🔐 重要操作必须服务器验证
3. 🔐 定期更新检测规则
4. 🔐 监控异常行为模式
5. 🔐 结合风控系统

---

**文档版本:** 1.0.0  
**最后更新:** 2025-10-23


